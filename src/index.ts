import {
  JupyterFrontEnd,
  JupyterFrontEndPlugin
} from '@jupyterlab/application';
import { INotebookTracker } from '@jupyterlab/notebook';
import { NotebookActions } from '@jupyterlab/notebook';
import { CodeCell, Cell, isCodeCellModel } from '@jupyterlab/cells';

import { ISettingRegistry } from '@jupyterlab/settingregistry';

type ChapyterCellMetaData = {
  linkedCellId?: string;
  cellType: 'generated' | 'original';
};

/**
 * Check if the cell is not generated by Chapyter
 */
function isCellNotGenerated(cell: Cell): boolean {
  if (isCodeCellModel(cell.model)) {
    let metadata =
      (cell.model.getMetadata('ChapyterCell') as ChapyterCellMetaData) || null;
    if (metadata && metadata.cellType === 'generated') {
      return false;
    }
  }
  return true;
}

/**
 * Iterate through the notebook and find the cell with the given ID
 */
function findCellById(notebook: any, id: string): Cell | null {
  for (let i = 0; i < notebook.widgets.length; i++) {
    let cell = notebook.widgets[i];
    if (cell.model.id === id) {
      return cell;
    }
  }
  return null;
}

/**
 * Check if the code cell is a Chapyter magic cell
 * i.e., the cell starts with %chat or %%chat
 */
function isCellChapyterMagicCell(cell: CodeCell): boolean {
  let codeCellText = cell.model.sharedModel.getSource();
  if (codeCellText.startsWith('%chat') || codeCellText.startsWith('%%chat')) {
    return true;
  }
  return false;
}

/**
 * Initialization data for the @shannon-shen/chapyter extension.
 */
const plugin: JupyterFrontEndPlugin<void> = {
  id: '@shannon-shen/chapyter:plugin',
  description: 'A Natural Language-Based Python Program Interpreter',
  autoStart: true,
  requires: [INotebookTracker],
  optional: [ISettingRegistry],
  activate: (app: JupyterFrontEnd, tracker: INotebookTracker) => {
    NotebookActions.executed.connect((sender, args) => {
      if (args.success && isCellNotGenerated(args.cell)) {
        console.log('Real Code cell was successfully executed');

        // It must be true that the cell is a code cell (otherwise it would not have been executed)
        let codeCell = args.cell as CodeCell;
        console.log('Executed cell:', codeCell);

        // We only want to automatically generate a new cell if the code cell starts with a magic command (e.g. %chat)
        if (isCellChapyterMagicCell(codeCell)) {
          // this is the original code cell that was executed
          if (codeCell.model.getMetadata('ChapyterCell') === undefined) {
            codeCell.model.setMetadata('ChapyterCell', {
              cellType: 'original'
            });
          }

          // because it is successfully executed
          let notebook = tracker.currentWidget;
          if (notebook) {
            /**
             * in the cell magic, it will automatically add a new cell below
             * the executed cell (args.cell). In the meantime, by default, the notebook
             * app will add a new cell below the executed cell -- and this is the current
             * active kernel. As such, we need to select the above cell and execute it.
             */
            NotebookActions.selectAbove(notebook.content);

            let newCell = notebook.content.activeCell as CodeCell;
            console.log('New cell:', newCell);
            if (newCell) {
              newCell.model.setMetadata('ChapyterCell', {
                cellType: 'generated',
                linkedCellId: codeCell.model.id // the original cell ID
              });
            }

            NotebookActions.run(notebook.content, notebook.sessionContext);
            NotebookActions.hideCode(notebook.content);
            NotebookActions.selectBelow(notebook.content);

            /**
             * We want to run the next check for avoiding duplicate cells.
             * Imagine when we are redistributing the notebook: we have already run the
             * chapter cell with the magic command, and the jupyter notebook generates
             * a new cell below the executed cell. Then another person opens the notebook
             * and executes the same chapyter cell. We want to delete the original generated
             * cell and only keep the newly generated cell.
             *
             * The logic is important: if it's on the same machine, then the caching mechanism
             * in guidance will produce us the same code and the user won't feel any difference.
             * However if it's on a different machine, then the generated code will become
             * different and the user will see a different result.
             *
             * We also need to execute this check after the previous cell is executed. Consider
             * the corner case when the (previous) generated cell is the last cell inside a juptyer
             * notebook. If we execute the check before the previous cell is executed, then jupyter
             * will move up (instead of moving down) the active cell and it will confuse the logic
             * for executing the next cell.
             */
            let linkedCellId =
              codeCell.model.getMetadata('ChapyterCell')?.linkedCellId;
            if (linkedCellId) {
              console.log('Linked cell ID:', linkedCellId);

              /**
               * This implementation only works when we do not hide the code
               * for the generated cell. If we hide the code, then it won't be
               * selected.
               */
              // let currentCell = notebook.content.activeCell as CodeCell;
              // if (currentCell.model.id == linkedCellId) {
              //   console.log(
              //     'Linked cell is the current cell, and we will delete it'
              //   );
              //   console.log('Current cell:', currentCell);

              //   notebook.content.select(currentCell);
              //   NotebookActions.deleteCells(notebook.content);
              //   // NotebookActions.insertBelow(notebook.content);
              // }
              let linkedCell = findCellById(notebook.content, linkedCellId);
              if (linkedCell) {
                console.log('Linked cell:', linkedCell);
                NotebookActions.deselectAll(notebook.content);
                notebook.content.select(linkedCell);
                NotebookActions.showCode(notebook.content);
                NotebookActions.selectAbove(notebook.content);
                NotebookActions.deleteCells(notebook.content);
              }
            }

            // set the proper linked cell ID
            codeCell.model.setMetadata('ChapyterCell', {
              cellType: 'original',
              linkedCellId: newCell.model.id
            });
          }
        }
      }
    });
  }
};

export default plugin;
